<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>VibifyEnv</title>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="style.css" />

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.js"
      integrity="sha512-dqw6X88iGgZlTsONxZK9ePmJEFrmHwpuMrsUChjAw1mRUhUITE5QU9pkcSox+ynfLhL15Sv2al5A0LVyDCmtUw=="
      crossorigin="anonymous"
    ></script>
    <script>
      let audioFeatures = {
        rms: 0,
        loudness: 1,
        energy: 0,
        spectralCentroid: 0,
        chroma: [],
        bpm: 0,
        scale: 0,
        beatSwitch: false,
        amplitudeSpectrum: [],
      };
      let scene;
      let arrayOfSmallObject = [];
    </script>
  </head>
  <body>
    <main id="main">
      <div class="audio-container">
        <div id="file-select-area">
          <div id="file-drop-area">
            <span>Drop file here or click to upload</span>
          </div>
        </div>
        <audio id="audioTag" controls autoplay>aa</audio>
        <div class="features">
          <div class="features-div">
            <h2>Affect Estimation (Essentia)</h2>
            <h3 id="arousalTag">Arousal:<br /></h3>
            <h3 id="valensTag">Valens:<br /></h3>

            <h3 id="sadTag">Sad:<br /></h3>
            <h3 id="happyTag">Happy:<br /></h3>

            <h3 id="relaxTag">Relax:<br /></h3>
            <h3 id="aggressiveTag">Agressive:<br /></h3>
            <h3 id="danceTag">Dance:<br /></h3>
          </div>
          <div class="features-div">
            <h2>Lables (Essentia)</h2>
            <h3 id="bpmTag">Bpm:<br /></h3>
            <h3 id="keyTag">Key:<br /></h3>
            <h3 id="scaleTag">Scale:<br /></h3>
          </div>
          <div class="features-div">
            <h2>Real Time Extraction (Meyda)</h2>
            <h3 id="loudnessTag">Loudness:<br /></h3>
            <h3 id="energyTag">Energy:<br /></h3>
            <h3 id="rmsTag">RMS:<br /></h3>
            <h3 id="spectralCentroidTag">Spectral Centroid:<br /></h3>
            <h3 id="chromaTag">Chroma:<br /></h3>
          </div>
        </div>
      </div>

      <div id="beatContainer">BEAT</div>
      <div id="testColor"></div>
      <canvas id="myCanvasId"></canvas>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/essentia.js@0.1.0/dist/essentia-wasm.web.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/essentia.js@0.1.0/dist/essentia.js-core.js"></script>

    <script
      type="text/javascript"
      src="https://unpkg.com/meyda@5.5.1/dist/web/meyda.min.js"
    ></script>

    <script type="module">
            import * as THREE from "./modules/three.module.js";
            import { OrbitControls } from "./modules/OrbitControls.js";
            import { addSmallCube } from "./geometry.js";

            function normalize(min, max) {
              var delta = max - min;
              return function (val) {
                return (val - min) / delta;
              };
            }

            function hslToHex(h, s, l) {
              l /= 100;
              const a = (s * Math.min(l, 1 - l)) / 100;
              const f = (n) => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color)
                  .toString(16)
                  .padStart(2, "0"); // convert to Hex and prefix "0" if needed
              };
              return `#${f(0)}${f(8)}${f(4)}`;
            }
            const testColorDiv = document.querySelector("#testColor");

            const x =-1;
            const y = -1;
            let angle = Math.atan2(x ,y) * 180 / Math.PI
            if(angle<0){
              angle+=360
            }
            console.dir(angle);

            const testColor = hslToHex(angle, 100, 50);
            console.dir(testColor);
            testColorDiv.style.background = testColor;

            function removeEntity(object) {
              var selectedObject = scene.getObjectByName(object.name);
              scene.remove(selectedObject);
            }

            // Camera
            scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(
              90,
              window.innerWidth /* *0.7 */ / window.innerHeight,
              0.1,
              1000
            );
            camera.position.z = 5;

            // Renderer
            const renderer = new THREE.WebGLRenderer({
              antialias: true,
              canvas: myCanvasId,
            });

            renderer.setClearColor(0x030303);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            const control = new OrbitControls(camera, renderer.domElement);

            // LIGHT
            const light = new THREE.AmbientLight(0xffffff, 0.05);
            scene.add(light);

            const pointLight = new THREE.PointLight(0xff00ff, 2, 17);
            pointLight.position.set(-5, 5, 5);
            pointLight.castShadow = true;
            scene.add(pointLight);

            const pointLight2 = new THREE.PointLight(0x00ffff, 2, 17);
            pointLight2.position.set(5, 5, 5);
            pointLight2.castShadow = true;
            scene.add(pointLight2);

            const sphereSize = 1;
            const pointLightHelper = new THREE.PointLightHelper(
              pointLight,
              sphereSize
            );

            // Geometry
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const materialShiny = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              roughness: 0.0,
              metalness: 0.2,
            });

            var docaGeo = new THREE.DodecahedronGeometry(1, 0);
            var doca = new THREE.Mesh(docaGeo, materialShiny);
            scene.add(doca);

            let chromaArrayBalls = [];
            function chromaBallsSpawn() {
              for (let index = 0; index < 256 / 4; index++) {
                const sphereGeometr = new THREE.SphereGeometry(0.1, 15, 15);
                const sphere = new THREE.Mesh(sphereGeometr, material);
                sphere.position.x = -6 + index / 5;
                sphere.position.y = 4;
                sphere.position.z = -5;
                scene.add(sphere);
                chromaArrayBalls.push(sphere);
              }
            }
            chromaBallsSpawn();

            // ANIMATE
            function animate() {
              requestAnimationFrame(animate);

              control.update();

              if (audioFeatures.amplitudeSpectrum.length > 0) {
                const minValue = Math.min(...audioFeatures.amplitudeSpectrum);
                const maxValue = Math.max(...audioFeatures.amplitudeSpectrum);
                /*  console.log("ampSpec: " + audioFeatures.amplitudeSpectrum);
                console.log(
                  "Normal ampSpec : " + audioFeatures.amplitudeSpectrum.map(normalize(minValue, maxValue))
                ); */
                audioFeatures["amplitudeSpectrum"] =
                  audioFeatures.amplitudeSpectrum.map(normalize(0, 128));

                chromaArrayBalls.forEach((ball, index) => {
                  const amp = audioFeatures.amplitudeSpectrum[index];
                  /*       console.dir("Min value: " + minValue)
                  console.dir("Max value: " + maxValue) */

                  /*     const normalizedValue = amp - minValue / maxValue - minValue; */
                  /*            console.dir("Amp: " + amp);
                  console.dir("Normalized: " + normalizedValue); */

                  ball.position.y = 4 + amp * 10;

                  /*  ball.scale.x = audioFeatures.chroma[index];
                  ball.scale.y = audioFeatures.chroma[index];
                  ball.scale.z = audioFeatures.chroma[index]; */
                });
              }

              /*         for (let i = 0; i < electronGroup.children.length; i++) {
               */ // Update the position of the electron
              /*    electronGroup.children[i].position.x = Math.sin((Date.now() / 1000) + (i * (Math.PI / 2))) * (i+1);
          electronGroup.children[i].position.y = Math.cos((Date.now() / 1000) + (i * (Math.PI / 3))) * (i+1);
          electronGroup.children[i].position.z = Math.tan((Date.now() / 1000) + (i * (Math.PI / 4))) * (i+1); */
              // Rotate the individual electron around the center
              /*     electronGroup.children[i].rotation.y += 0.01;
               */
              /*   electronGroup.children[i].position.x = Math.sin((Date.now() / 1000) + (i * (Math.PI / 2))) * 3;
          electronGroup.children[i].position.y = Math.cos((Date.now() / 1000) + (i * (Math.PI / 2))) * 3;
       */
              /* electronGroup.children[i].position.x = Math.sin((Date.now() / 1000) + (i * (Math.PI / 2))) * 3;
          electronGroup.children[i].position.y = Math.cos((Date.now() / 1000) + (i * (Math.PI / 3))) * 3;
          electronGroup.children[i].position.z = Math.tan((Date.now() / 1000) + (i * (Math.PI / 4))) * 3; */
              /*  electronGroup.rotation.y += 0.01; */
              /*     } */
              // Rotate the entire group of electrons
              // this will rotate the group in y-axis by 0.01 radians per frame

              /*  var time = Date.now() * 0.001;
              electronList.forEach((electron, index) => {
                const muliplication = index;
                const timeAddition = index /2;

                electron.mesh.position.x =
                Math.sin((Date.now() / 1000) + (index * (Math.PI / 4))) * 3;
                electron.mesh.position.y =
                Math.cos((Date.now() / 1000) + (index * (Math.PI / 4))) * 3;
               electron.mesh.position.z =
                  muliplication * Math.sin(time * 2 + timeAddition);
              }); */

              /*   electron1.mesh.position.x = 1.5 * Math.cos(time * 2);
              electron1.mesh.position.y = 1.5 * Math.sin(time * 2);
              electron1.mesh.position.z = 1.5 * Math.sin(time * 2);
              electron2.mesh.position.x = 0 * Math.cos(time * 2 + 0.5);
              electron2.mesh.position.y = 3 * Math.sin(time * 2 + 0.5);
              electron2.mesh.position.z = 2 * Math.cos(time * 2 + 0.5);
              electron3.mesh.position.x = 2.5 * Math.sin(time * 2 + 1);
              electron3.mesh.position.y = 2.5 * Math.cos(time * 2 + 1);
              electron3.mesh.position.z = 2.5 * Math.sin(time * 2 + 1);
       */
              /*  arrayOfSmallObject.forEach((object) => {

                object.position.y -= 0.03;
                object.scale.x = (audioFeatures["loudness"] / 200) * 3;
                object.scale.y = (audioFeatures["loudness"] / 200) * 3;
                object.scale.z = (audioFeatures["loudness"] / 200) * 3;
                if (object.position.y < -3) {
                  scene.remove(object);
                }
              }); */
              if (audioFeatures.beatSwitch) {
                doca.rotation.x += audioFeatures.rms / 5;
                doca.rotation.y += audioFeatures.energy / 160;
              } else {
                doca.rotation.x -= audioFeatures.rms / 5;
                doca.rotation.y -= audioFeatures.energy / 160;
              }

              doca.scale.x = 1 + (audioFeatures["loudness"] / 100) * 3;
              doca.scale.y = 1 + (audioFeatures["loudness"] / 100) * 3;
              doca.scale.z = 1 + (audioFeatures["loudness"] / 100) * 3;

              renderer.render(scene, camera);
            }

            animate();
    </script>
    <script src="src/main.js" type="module" async defer></script>
  </body>
</html>
