<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>VibifyEnv</title>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="style.css" />

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.js"
      integrity="sha512-dqw6X88iGgZlTsONxZK9ePmJEFrmHwpuMrsUChjAw1mRUhUITE5QU9pkcSox+ynfLhL15Sv2al5A0LVyDCmtUw=="
      crossorigin="anonymous"
    ></script>
    <script>
      let audioFeatures = {
        rms: 0,
        loudness: 1,
        energy: 0,
        spectralCentroid: 0,
        chroma: [],
        bpm: 0,
        scale: 0,
        beatSwitch: false,
      };
      let scene;
      let arrayOfSmallObject = [];
    </script>
  </head>
  <body>
    <main id="main">
      <div class="audio-container">
        <div id="file-select-area">
          <div id="file-drop-area">
            <span>Drop file here or click to upload</span>
          </div>
        </div>
        <audio id="audioTag" controls autoplay>aa</audio>
        <div class="features">
          <div class="features-div">
            <h2>Affect Estimation (Essentia)</h2>
            <h3 id="arousalTag">Arousal:<br /></h3>
            <h3 id="valensTag">Valens:<br /></h3>

            <h3 id="sadTag">Sad:<br /></h3>
            <h3 id="happyTag">Happy:<br /></h3>

            <h3 id="relaxTag">Relax:<br /></h3>
            <h3 id="aggressiveTag">Agressive:<br /></h3>
            <h3 id="danceTag">Dance:<br /></h3>
          </div>
          <div class="features-div">
            <h2>Lables (Essentia)</h2>
            <h3 id="bpmTag">Bpm:<br /></h3>
            <h3 id="keyTag">Key:<br /></h3>
            <h3 id="scaleTag">Scale:<br /></h3>
          </div>
          <div class="features-div">
            <h2>Real Time Extraction (Meyda)</h2>
            <h3 id="loudnessTag">Loudness:<br /></h3>
            <h3 id="energyTag">Energy:<br /></h3>
            <h3 id="rmsTag">RMS:<br /></h3>
            <h3 id="spectralCentroidTag">Spectral Centroid:<br /></h3>
            <h3 id="chromaTag">Chroma:<br /></h3>
          </div>
        </div>
      </div>

      <div id="beatContainer">BEAT</div>
      <!-- <div id="emotionModel-container">
        <div id="emotionModel-marker"></div>
        <img id="emotionModel" src="./assets/emotion_model.png" />
      </div> -->
      <canvas id="myCanvasId"></canvas>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/essentia.js@0.1.0/dist/essentia-wasm.web.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/essentia.js@0.1.0/dist/essentia.js-core.js"></script>

    <script
      type="text/javascript"
      src="https://unpkg.com/meyda@5.5.1/dist/web/meyda.min.js"
    ></script>

    <script type="module">
      import * as THREE from "./modules/three.module.js";
      import { OrbitControls } from "./modules/OrbitControls.js";
      import { addSmallCube } from "./geometry.js";

      scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        90,
        window.innerWidth /* *0.7 */ / window.innerHeight,
        0.1,
        1000
      );
      /*  const camera = new THREE.OrthographicCamera(window.innerWidth / - 2, window.innerWidth / 2,  window.innerHeight / 2,  window.innerHeight / - 2, 1, 1000
      ); */

      const renderer = new THREE.WebGLRenderer({
        /* alpha: true, */
        antialias: true,

        canvas: myCanvasId,
      });
      renderer.setClearColor(0x030303);
      renderer.setSize(window.innerWidth /*  *0.7 */, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

      const light = new THREE.AmbientLight(0xffffff, 0.05);

      scene.add(light);

      const pointLight = new THREE.PointLight(0xff00ff, 2, 17);
      pointLight.position.set(-5, 5, 5);
      pointLight.castShadow = true;

      scene.add(pointLight);

      const sphereSize = 1;
      const pointLightHelper = new THREE.PointLightHelper(
        pointLight,
        sphereSize
      );

      const pointLight2 = new THREE.PointLight(0x00ffff, 2, 17);
      pointLight2.position.set(5, 5, 5);
      pointLight2.castShadow = true;

      scene.add(pointLight2);

      const pointLightHelper2 = new THREE.PointLightHelper(
        pointLight2,
        sphereSize
      );

      const pointLight3 = new THREE.PointLight(0xffffff, 0.2, 1000);
      pointLight3.position.set(0, 0, 10);
      pointLight3.castShadow = true;
      /*   scene.add(pointLight3); */

      const pointLightHelper3 = new THREE.PointLightHelper(pointLight3, 2);

      /* scene.add(pointLightHelper);
      scene.add(pointLightHelper2);
      scene.add(pointLightHelper3);
 */
      function removeEntity(object) {
        var selectedObject = scene.getObjectByName(object.name);
        scene.remove(selectedObject);
      }

      const geometry = new THREE.BoxGeometry(1, 1, 1);

      const material = new THREE.MeshLambertMaterial({ color: 0xffffff });
      const materialShiny = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.0,
        metalness: 0.2,
      });
      const cube = new THREE.Mesh(geometry, material);
      cube.castShadow = true;
      cube.rotation.x = 0.8;
      cube.rotation.y = 0.8;
      /*       scene.add(cube);
       */ camera.position.z = 5;

      const control = new OrbitControls(camera, renderer.domElement);
      /*      const helper = new THREE.CameraHelper( pointLight2.shadow.camera );
scene.add( helper ); */
      var geo = new THREE.PlaneBufferGeometry(10, 10, 8, 8);
      var mat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
      });

      var plane = new THREE.Mesh(geo, mat);
      plane.rotation.x = 3.1415 / 2;
      plane.position.y = -3;
/*       scene.add(plane);
 */      plane.receiveShadow = true;

      var docaGeo = new THREE.DodecahedronGeometry(1, 0);
      var doca = new THREE.Mesh(docaGeo, materialShiny);

      scene.add(doca);

      let chromaArrayBalls = [];
      function chromaBallsSpawn() {
        for (let index = 0; index < 256 / 4; index++) {
          const sphereGeometr = new THREE.SphereGeometry(0.1, 15, 15);
          const sphere = new THREE.Mesh(sphereGeometr, material);
          sphere.position.x = -6 + index / 5;
          sphere.position.y = 4;
          sphere.position.z = -5;
          scene.add(sphere);
          chromaArrayBalls.push(sphere);
        }
      }
      chromaBallsSpawn();

      class Electron {
        constructor() {
          this.mesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xff0000 })
          );
          this.mesh.position.set(0, 0, 0);
        }
        addToScene(scene) {
          scene.add(this.mesh);
        }
      }
      var electronList = [];
      for (let index = 0; index < 2; index++) {
        const electron = new Electron();
        electron.addToScene(scene);
        electronList.push(electron);
      }

      const electronGeometry = new THREE.SphereGeometry(0.2, 32, 32);
      const electronMaterial = new THREE.MeshStandardMaterial({
        color: 0x0000ff,
      });
      const electronGroup = new THREE.Group();

      /* for(let i = 0; i < 30; i++) {
  const electronMesh = new THREE.Mesh(electronGeometry, electronMaterial);
  // Set the initial position of the electron
  electronMesh.position.set(i, 0, 0);
  electronGroup.add(electronMesh);
} */
      scene.add(electronGroup);
      // ANIMATE
      function animate() {
        requestAnimationFrame(animate);

        control.update();
        if (audioFeatures.chroma.length > 0) {
          const minValue = Math.min(...audioFeatures.amplitudeSpectrum);
            const maxValue = Math.max(...audioFeatures.amplitudeSpectrum);
          chromaArrayBalls.forEach((ball, index) => {
            const amp = audioFeatures.amplitudeSpectrum[index];

           

            const normalizedValue = amp - minValue / maxValue - minValue;
            
            ball.position.y = 4+  normalizedValue/10*0.4;

            /*  ball.scale.x = audioFeatures.chroma[index];
            ball.scale.y = audioFeatures.chroma[index];
            ball.scale.z = audioFeatures.chroma[index]; */
          });
        }
        for (let i = 0; i < electronGroup.children.length; i++) {
          // Update the position of the electron
          /*    electronGroup.children[i].position.x = Math.sin((Date.now() / 1000) + (i * (Math.PI / 2))) * (i+1);
    electronGroup.children[i].position.y = Math.cos((Date.now() / 1000) + (i * (Math.PI / 3))) * (i+1);
    electronGroup.children[i].position.z = Math.tan((Date.now() / 1000) + (i * (Math.PI / 4))) * (i+1); */
          // Rotate the individual electron around the center
          /*     electronGroup.children[i].rotation.y += 0.01;
           */
          /*   electronGroup.children[i].position.x = Math.sin((Date.now() / 1000) + (i * (Math.PI / 2))) * 3;
    electronGroup.children[i].position.y = Math.cos((Date.now() / 1000) + (i * (Math.PI / 2))) * 3;
 */
          /* electronGroup.children[i].position.x = Math.sin((Date.now() / 1000) + (i * (Math.PI / 2))) * 3;
    electronGroup.children[i].position.y = Math.cos((Date.now() / 1000) + (i * (Math.PI / 3))) * 3;
    electronGroup.children[i].position.z = Math.tan((Date.now() / 1000) + (i * (Math.PI / 4))) * 3; */
          /*  electronGroup.rotation.y += 0.01; */
        }
        // Rotate the entire group of electrons
        // this will rotate the group in y-axis by 0.01 radians per frame

        /*  var time = Date.now() * 0.001;
        electronList.forEach((electron, index) => {
          const muliplication = index;
          const timeAddition = index /2;

          electron.mesh.position.x =
          Math.sin((Date.now() / 1000) + (index * (Math.PI / 4))) * 3;
          electron.mesh.position.y =
          Math.cos((Date.now() / 1000) + (index * (Math.PI / 4))) * 3;
         electron.mesh.position.z =
            muliplication * Math.sin(time * 2 + timeAddition); 
        }); */

        /*   electron1.mesh.position.x = 1.5 * Math.cos(time * 2);
        electron1.mesh.position.y = 1.5 * Math.sin(time * 2);
        electron1.mesh.position.z = 1.5 * Math.sin(time * 2);
        electron2.mesh.position.x = 0 * Math.cos(time * 2 + 0.5);
        electron2.mesh.position.y = 3 * Math.sin(time * 2 + 0.5);
        electron2.mesh.position.z = 2 * Math.cos(time * 2 + 0.5);
        electron3.mesh.position.x = 2.5 * Math.sin(time * 2 + 1);
        electron3.mesh.position.y = 2.5 * Math.cos(time * 2 + 1);
        electron3.mesh.position.z = 2.5 * Math.sin(time * 2 + 1);
 */
        /*  arrayOfSmallObject.forEach((object) => {
       
          object.position.y -= 0.03;
          object.scale.x = (audioFeatures["loudness"] / 200) * 3;
          object.scale.y = (audioFeatures["loudness"] / 200) * 3;
          object.scale.z = (audioFeatures["loudness"] / 200) * 3;
          if (object.position.y < -3) {
            scene.remove(object);
          }
        }); */
        if (audioFeatures.beatSwitch) {
          doca.rotation.x += audioFeatures.rms / 5;
          doca.rotation.y += audioFeatures.energy / 160;
        } else {
          doca.rotation.x -= audioFeatures.rms / 5;
          doca.rotation.y -= audioFeatures.energy / 160;
        }

        doca.scale.x = 1 + (audioFeatures["loudness"] / 100) * 3;
        doca.scale.y = 1 + (audioFeatures["loudness"] / 100) * 3;
        doca.scale.z = 1 + (audioFeatures["loudness"] / 100) * 3;

        renderer.render(scene, camera);
      }

      animate();
    </script>
    <script src="src/main.js" type="module" async defer></script>
  </body>
</html>
